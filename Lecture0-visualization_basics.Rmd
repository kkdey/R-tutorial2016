---
title: "Basics of R"
author: "Kushal K Dey"
date: "July 27, 2016"
output: 
  html_document:
    css: floating-toc.css
    toc: true
---

We look at some simple commands to familiarise with R

To install and load a package

```{r echo=TRUE, eval=FALSE}
install.packages("vegan")
library(vegan)
```

To know about the documentation of this function

```{r echo=TRUE, eval=FALSE}
help(vegan)
help(adonis, package="vegan")
```

A random number generator 

```{r}
runif(1,0,1) ## one random draw from 0 to 1
runif(100, 0, 1) ## 100 random draws from 0 to 1
runif(1,10,11) ## 1 random draw from 10 to 11
runif(10, -100, 100) ## 10 random draws from -100 to 100
```

Create a vector

```{r}
##  use <- or = to assign 
vec <- c(23, 14, 56, 76, 3, 2);
vec = c(23, 14, 56, 76, 3, 2); ## same as above
length(vec) ## gives you the size of the vector
class(vec) ## what kind of a vector is it?
```

A vector of repeated elements 

```{r}
rep(2,length=10) ## repeat 2 10 times in a vector
seq(1,10, length.out=20) ## 20 uniformly spaced points between 1 and 10
seq(1,10,0.01) ## points at gaps of 0.01 from 1 to 10
```

```{r}
mean(vec)
median(vec)
sort(vec)
order(vec)
min(vec)
max(vec)
```


To build a long vector, we use the for loop.

```{r}
vec <- array(0,1000);
for(i in 1:1000){
  vec[i] = runif(1,0,1)
}
```

Suppose you have two vectors. We can plot them in a scatter plot. 

```{r}
vec1 <- c(10, 20, 30, 40, 50);
vec2 <- c(2, 5, 10, 12, 20);
plot(vec1, vec2)

## shape of the points determination in the plot

plot(vec1, vec2, pch=20)

## line width of the points in the plot

plot(vec1, vec2, pch=20, lwd=10)
plot(vec1, vec2, pch=7, lwd=10)
plot(vec1, vec2, pch=2, lwd=10)

## What pch to choose...look up documentation

?pch

## color the points 

plot(vec1, vec2, pch=20, lwd=1, col="red")

## Add title to the plot

plot(vec1, vec2, pch=20, lwd=1, col="red", main="Scatter Plot")

##  Fix the margin of the plot
par(mar=c(4,4,4,4)) 
plot(vec1, vec2, pch=20, lwd=1, col="red", main="Scatter Plot",
     xlab="X", ylab="Y")

## A new margin of the plot

par(mar=c(8,5,5,5)) 
plot(vec1, vec2, pch=20, lwd=1, col="red", main="Scatter Plot",
     xlab="X", ylab="Y")

par(mar=c(4,4,4,4)) 
plot(vec1, vec2, pch=20, lwd=1, col="red", main="Scatter Plot",
     xlab="X", ylab="Y")

## control size of the points in the plot

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=10, main="Scatter Plot", xlab="X", ylab="Y")

## cex.main controls the size of the title

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.main=4)

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.main=0.5)

## cex.axis controls the size of the axis labels

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=2)

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3)

## if you want a line plot instead of scatter plot

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3, type="l")

## fix aspect ratio 

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3, type="l", asp=1)

## Fix xlim and ylim

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3, type="l", asp=1,
     xlim=c(0,100), ylim=c(-20,40))

## For fancier looking plot, use qplot() of package ggplot2

ggplot2::qplot(vec1, vec2, col="red", main="Scatter Plot", xlab="X", ylab="Y", xlim=c(0,50), ylim=c(-5,25))

```

We have a measure called correlation that tells us whether there is a strong positive or negative association between two vectors.Correlation is a measure between -1 and 1. It is -1 when there is a strong negative linear association, +1 when there is a strong positive linear association and 0 when there is no linear association.

```{r}
vec1 <- c(10, 20, 30, 40, 50);
vec2 <- c(2, 5, 10, 12, 20);
cor(vec1, vec2)

vec1 <- c(10, 20, 30, 40, 50);
vec2 <- c(20, 12, 10, 5, 2);
cor(vec1, vec2)

vec1 <- c(10, 20, 30, 40, 50);
vec2 <- c(4, 4.1, 3.2, 4.0, 3.8)
cor(vec1, vec2)
```

Two plots in the same frame

```{r}
vec1 <- c(10, 20, 30, 40, 50);
vec2 <- c(2, 5, 10, 12, 40);
vec3 <- c(0.5, 7, 20, 25, 30);

plot(vec1, vec2, pch=20, lwd=1, col="red", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3, type="l")
points(vec1, vec3, pch=20, lwd=1, col="green", cex=1, main="Scatter Plot", xlab="X", ylab="Y", cex.axis=0.3, type="l")

```

Have multiple subplots 

```{r}
multiplot <- function(..., plotlist=NULL, cols) {
    require(grid)

    # Make a list from the ... arguments and plotlist
    plots <- c(list(...), plotlist)

    numPlots = length(plots)

    # Make the panel
    plotCols = cols                          # Number of columns of plots
    plotRows = ceiling(numPlots/plotCols) # Number of rows needed, calculated from # of cols

    # Set up the page
    grid.newpage()
    pushViewport(viewport(layout = grid.layout(plotRows, plotCols)))
    vplayout <- function(x, y)
        viewport(layout.pos.row = x, layout.pos.col = y)

    # Make each plot, in the correct location
    for (i in 1:numPlots) {
        curRow = ceiling(i/plotCols)
        curCol = (i-1) %% plotCols + 1
        print(plots[[i]], vp = vplayout(curRow, curCol ))
    }

}
```


```{r}

par(mfrow=c(1,2))
plot(vec1, vec2, col="red", pch=20, main="Scatter Plot", xlab="X", ylab="Y")
plot(vec1, vec3, col="red", pch=20, main="Scatter Plot", xlab="X", ylab="Y")

## build a plot with 2 frames in columns
## for ggplot2

plot1 <- ggplot2::qplot(vec1, vec2, main="Scatter Plot", xlab="X", ylab="Y")
plot2 <- ggplot2::qplot(vec1, vec3, main="Scatter Plot", xlab="X", ylab="Y")
multiplot(plot1, plot2, cols=2)

```


## Matrix Operations

```{r}
mat <- matrix(0, nrow=2, ncol=2);
mat[1,1] <- 3
mat[1,2] <- 5
mat[2,1] <- mat[1,1] + mat[1,2];
```


```{r}
diagmat <- diag(c(24,56,2))
```

Matrix operations 

```{r}

## transpose of a matrix

t(mat)

## inverse of a mtrix

inv_mat <- solve(mat)
print(inv_mat)

## multiplication of two matrices

mat %*% inv_mat ## the dimensions must be proper

diag(mat) ## gives the diagonal entries of a matrix

mat[1,] ## access 1st row of a matrix
mat[,1] ## access 1st column of a matrix

vec1 <- c(12, 24, 56);
vec2 <- c(10, 3, 5);

mat <- cbind(vec1, vec2) ## bind vectors as columns
mat <- rbind(vec1, vec2) ## bind vectors as rows 

solve(mat) ## will give ERROR (dimensions must be square)

```


We can also define a multi-dimensional array in R (in 3 dimensions)

```{r}
mult_mat <- array(0, c(2,3,2));
mult_mat[1,,] <- rbind(c(3,4), c(5,6), c(1,2));
mult_mat[2,,] <- rbind(c(5,2), c(10,0), c(1,6));
print(mult_mat)
dim(mult_mat)
```

We can create lists that store objects of any types.

```{r}
lst <- list(0.5, 0.841, 0.977)
lst <- list(mid=0.5, right=0.841, top=0.977, bottom = 0.4)
lst[[1]]
lst$mid
lst$right
list_vec <- vector(mode="list");
list_vec[[1]] <- mult_mat;
list_vec[[2]] <- mat;
list_vec[[3]] <- vec2;
list_vec[[4]] <- 0

list_vec <- vector(mode="list");
list_vec[["first"]] <- mult_mat;
list_vec[["second"]] <- mat;
list_vec[["third"]] <- vec2;
list_vec[["fourth"]] <- 0

list_vec$second
list_vec$third

```

Apply functions on matrices and lists 

```{r}
## apply a function on a matrix

## apply on the columns

apply(mat,2,mean)
apply(mat,2, function(x) min(x))

## apply on rows

apply(mat,1,sd)
apply(mat,1,function(x) max(x) - min(x))

## apply on each element

apply(mat, c(1,2), function(x) log(x))

## we consider a vector now

head(vec)
length(vec)
sapply(vec, function(x) log(x) + x^2) ## function on each element of a vector

## apply function on each eleemnt of a list


```

